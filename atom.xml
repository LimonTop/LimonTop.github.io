<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Limon's Blog]]></title>
  <link href="http://limon-.github.io//atom.xml" rel="self"/>
  <link href="http://limon-.github.io//"/>
  <updated>2015-01-22T18:51:37+08:00</updated>
  <id>http://limon-.github.io//</id>
  <author>
    <name><![CDATA[Limon]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[内存管理 - ARC]]></title>
    <link href="http://limon-.github.io//blog/2015/01/22/nei-cun-guan-li-arc/"/>
    <updated>2015-01-22T18:20:16+08:00</updated>
    <id>http://limon-.github.io//blog/2015/01/22/nei-cun-guan-li-arc</id>
    <content type="html"><![CDATA[<p>ARC的一个基本规则即是，只要某个对象被任一strong指针指向，那么它将不会被销毁。</p>

<p>如果对象没有被任何strong指针指向，那么就将被销毁。在默认情况下，所有的实例变量和局部变量都是strong类型的。可以说strong类型的指针在行为上和MRC时代retain的property是比较相似的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[内存管理 - 引用计数器]]></title>
    <link href="http://limon-.github.io//blog/2015/01/22/nei-cun-guan-li-yin-yong-ji-shu-qi/"/>
    <updated>2015-01-22T14:27:14+08:00</updated>
    <id>http://limon-.github.io//blog/2015/01/22/nei-cun-guan-li-yin-yong-ji-shu-qi</id>
    <content type="html"><![CDATA[<h1>内存管理 - 引用计数器</h1>

<h2>内存管理概述</h2>

<p>在Objective-C中，系统并不会自动释放堆中的内存，其他高级语言C#、JAVA都有垃圾回收机制，但在Objective-C中并没有垃圾回收机制，那么Objective-C中的内存是如何管理？
Objective-C语言使用引用计数器来管理内存，每个对象都有个可以递增或递减的计数器。如果想使某个对象继续存活，那就递增其引用计数器；用完之后，就递减其计数器；当计数器为0，就表示没人关注此对象，此对象就会被销毁。</p>

<h2>引用计数工作原理</h2>

<p>在引用计数架构下，对象有个计数器，用以表示当前有多少个事物想令此对象继续存活。
NSObject协议声明了三个方法用于操作计数器</p>

<ul>
<li>Retain 递增计数器</li>
<li>Release 递减计数器</li>
<li>autorelease 待销毁autorelease pool时，再递减pool内的全部计数器</li>
</ul>


<p>1.对一个对象发送alloc、retain、new、copy消息，计数器 +1</p>

<p>2.对一个对象发送release消息，计数器 -1</p>

<p>3.当一个对象的引用计数器为0，对象就被回收(dealloced)，也就是说，系统会将对象其占用的内存标记为“可重用”(reuse)，放到“可用内存池”(avaiable pool)</p>

<h3>手动管理内存的三点原则</h3>

<ul>
<li>如果需要持有一个对象，那么对其发送retain</li>
<li>如果之后不再使用该对象，那么需要对其发送release（或者autorealse）</li>
<li>每一次对retain,alloc或者new的调用，需要对应一次release或autorealse调用</li>
</ul>


<h3>图表演示</h3>

<p>下图演示了一个对象自创建出来之后经历一次retain及两次release操作的过程
<img src="http://limons-gitimage.stor.sinaapp.com/Memory.png" alt="Memory" /></p>

<p>下图所示的对象图中，ObjectB和ObjectC都引用了ObjectA，若B和C都不再使用A，则其计数器为0，便被回收。还有OrderObject想令B和C继续存活，而应用程序里又有另外的对象想令OrderObject继续存活，如果按“引用树“回溯，那么会发现一个“根对象”，在iOS中，则是UIApplication对象。此”根对象”是应用程序启动时创建的单例。
<img src="http://limons-gitimage.stor.sinaapp.com/Memory-2.png" alt="Memory" /></p>

<h3>代码演示</h3>

<pre><code>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
    NSMutableArray *array = [[NSMutableArray alloc] init];
    NSNumber *number = [[NSNumber alloc] initWithInt:1337]; 

    [array addObject:number]; //number的引用计数器+1（此时number的引用计数器至少为2）
    [number release]; // -1

    // do something with `array’

    [array release];
    return YES;
}
</code></pre>

<blockquote><p>在调用数组的<code>-addObject</code>方法时，数组也会在number上调用retain，以期令此对象存活</p></blockquote>

<h2>引用计数的应用场景</h2>

<p>在上面的代码演示中，还不看出引用计数的真正用处。在函数内使用一个临时的对象，通常不需要修改引用计数，只需在甘薯返回前将该对象销毁即可。
引用计数真正的应用场景是，用于对象之间传递和共享数据。</p>

<h2>引用计数的注意要点</h2>

<h3>retainCount可能永远不为0</h3>

<p>可能有人会测试对象释放时，看retainCount是否为0，代码如下：</p>

<pre><code>NSObject *object = [[NSObject alloc] init];
NSLog(@"%lu",(unsigned long)[object retainCount]);
[object release];
NSLog(@"%lu",(unsigned long)[object retainCount]);
</code></pre>

<p>但是，打印的结果是 1  1
最后一次输出，引用计数并没有变成0，原因是在最后一次 release 时，系统马上就回收了内存，就没有再将retainCount减1，因为不将值从1变成0，可以减少一次内存操作，加快对象的回收，只有在系统不打算这么优化时，计数值才会递减为0</p>

<h3>悬挂指针</h3>

<p>为什么对象被回收了，向其发送消息不会崩？代码如下：</p>

<pre><code>NSNumber *number = [[NSNumber alloc] initWithInt:1337];

[number release];

NSLog(@"number = %@",number);
</code></pre>

<p>内存已经被回收，如果向其发送消息，可能使程序崩溃。为什么说“可能”，而没说“一定”，是因为对象的所占的内存在“解除分配”(deallocated)之后，只是放回了“可用内存池”(avaiable pool)。如果在执行NSLog时尚未覆写对象内存，那么该对象仍然有效。</p>

<blockquote><p>由此可见，因过早释放对象而导致的bug很难调试</p></blockquote>

<p>为了防止此情况的发送，一般release之后都会清空指针</p>

<pre><code>NSNumber *number = [[NSNumber alloc] initWithInt:1337];

[number release];
number = nil; // 悬挂指针（dangling pointer）
</code></pre>

<blockquote><p>在Objective-C中，向nil发送消息不会出错。</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[内存管理のAutorelease]]></title>
    <link href="http://limon-.github.io//blog/2015/01/19/autoreleasepool/"/>
    <updated>2015-01-19T16:12:34+08:00</updated>
    <id>http://limon-.github.io//blog/2015/01/19/autoreleasepool</id>
    <content type="html"><![CDATA[<p>Autorelease实际上只是把对release的调用延迟了，对于每一个Autorelease，系统只是把该Object放入了当前的Autorelease pool中，当该pool被释放时，该pool中的所有Object会被调用release，也就是计数器会减1，但是自动释放池被销毁了，里面的对象并不一定会被销毁。</p>

<p>简而言之，autorelease pool 避免了频繁申请/释放内存。</p>

<h2>pool什么时候被销毁？</h2>

<p>在每一个Runloop结束时，当前栈顶的Autorelease pool会被销毁，此pool内的OC对象会被release。
那什么是一个Runloop呢？ 一个UI事件，Timer call， delegate call， 都会是一个新的Runloop</p>

<p>在Iphone项目中，大家会看到一个默认的Autorelease pool，程序开始时创建，程序退出时销毁，按照对Autorelease的理解，岂不是所有autorelease pool里的对象在程序退出时才release， 这样跟内存泄露有什么区别？</p>

<p>答案是，对于每一个Runloop， 系统会隐式创建一个Autorelease pool，这样所有的release pool会构成一个栈式结构，遵循先进后出，在每一个Runloop结束时，当前栈顶的Autorelease pool会被销毁，这样这个pool里的每个OC对象会被release。</p>

<h2>pool嵌套，栈式结构</h2>

<p>对于每一个Runloop， 系统会隐式创建一个Autorelease pool，这样所有的release pool会构成一个栈式结构，遵循先进后出</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#import &lt;Foundation/Foundation.h&gt; 
</span><span class='line'>#import "Person.h" 
</span><span class='line'>int main(int argc, const char * argv[]) 
</span><span class='line'>{ 
</span><span class='line'>     
</span><span class='line'>    // 自动释放池1 
</span><span class='line'>    @autoreleasepool { 
</span><span class='line'>         
</span><span class='line'> // 对象的释放交给 自动释放池去管理 不用再写[person release] 
</span><span class='line'>        Person *person = [[Person alloc] init];  
</span><span class='line'>         
</span><span class='line'>        // 再创建一个自动释放池2 
</span><span class='line'>        @autoreleasepool { 
</span><span class='line'>             
</span><span class='line'>            Person *person2 = [[Person alloc] init]; 
</span><span class='line'>        } 
</span><span class='line'>        
</span><span class='line'>        Person *person3 = [[Person alloc] init];    
</span><span class='line'>    } 
</span><span class='line'>    return 0; 
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>pool2先被销毁，最后才是pool1，即释放顺序：person2 -> person3/person2</p>

<h3>#</h3>

<h4>一下内容整理于 #<a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/">黑幕背后的Autorelease</a></h4>

<p>在ARC下，<code>@autoreleasepool{}</code>创建一个AutoreleasePool，随后编译器将其改写成下面的样子：</p>

<pre><code>void *context = objc_autoreleasePoolPush();
// {}中的代码
objc_autoreleasePoolPop(context);
</code></pre>

<p>而这两个函数都是对AutoreleasePoolPage的简单封装，所以自动释放机制的核心就在于这个类。</p>

<pre><code>class AutoreleasePoolPage 
{
    .....
    magic_t const magic;
    id *next;
    pthread_t const thread;
    AutoreleasePoolPage * const parent;
    AutoreleasePoolPage *child;
    uint32_t const depth;
    uint32_t hiwat;
    ....
}
</code></pre>

<ul>
<li>AutoreleasePool并没有单独的结构，而是由若干个AutoreleasePoolPage以双向链表的形式组合而成（分别对应结构中的parent指针和child指针）</li>
<li>AutoreleasePool是按线程一一对应的（结构中的thread指针指向当前线程）</li>
<li>AutoreleasePoolPage每个对象会开辟4096字节内存（也就是虚拟内存一页的大小），除了上面的实例变量所占空间，剩下的空间全部用来储存autorelease对象的地址</li>
<li>上面的id *next指针作为游标指向栈顶最新add进来的autorelease对象的下一个位置</li>
<li>一个AutoreleasePoolPage的空间被占满时，会新建一个AutoreleasePoolPage对象，连接链表，后来的autorelease对象在新的page加入</li>
</ul>


<h2>总结</h2>

<ul>
<li>autorelease方法不会改变对象的引用计数器，只是将这个对象放到自动释放池中；</li>
<li>自动释放池实质是当自动释放池销毁后调用对象的release方法，不一定就能销毁对象（例如如果一个对象的引用计数器>1则此时就无法销毁）；</li>
<li>由于自动释放池最后统一销毁对象，因此如果一个操作比较占用内存（对象比较多或者对象占用资源比较多），最好不要放到自动释放池或者考虑放到多个自动释放池；</li>
<li>ObjC中类库中的静态方法一般都不需要手动释放，内部已经调用了autorelease方法；</li>
</ul>


<p><a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/">黑幕背后的Autorelease</a></p>

<p><a href="http://www.cnblogs.com/kenshincui/p/3870325.html#autoreleasepool">Objective-C之内存管理</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Reading record]]></title>
    <link href="http://limon-.github.io//blog/2015/01/19/reading-record/"/>
    <updated>2015-01-19T10:16:07+08:00</updated>
    <id>http://limon-.github.io//blog/2015/01/19/reading-record</id>
    <content type="html"><![CDATA[<h1>Reading record</h1>

<h2>ReactiveCocoa</h2>

<p><a href="http://iiiyu.com/2014/12/26/learning-ios-notes-thirty-six/">ReactiveCocoa 用 RACSignal 替代 Delegate</a></p>

<h2>动画</h2>

<p><a href="http://yingkong1987.github.io/blog/2014/05/05/playing-with-pop.html">玩转Facebook开源的Pop库</a></p>

<h2>CocoaPods</h2>

<p><a href="http://blog.devtang.com/blog/2014/05/25/use-cocoapod-to-manage-ios-lib-dependency/">用CocoaPods做iOS程序的依赖管理</a></p>

<p><a href="http://gracelancy.com/blog/2013/08/11/make-your-own-cocoapods-spec/">制作自己的CocoaPods Spec</a></p>

<p><a href="http://www.iwangke.me/2013/04/18/advanced-cocoapods/">CocoaPods进阶：本地包管理</a></p>

<h2>杂</h2>

<p><a href="http://blog.sunnyxx.com/2014/12/20/64-bit-tips/">64-bit Tips</a></p>

<p><a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/">黑幕背后的Autorelease</a></p>

<p><a href="http://mobile.51cto.com/iphone-284112.htm">Objective-C内存管理如何理解Autorelease</a></p>

<p><a href="http://cocoa.venj.me/blog/view-controller-based-status-bar-style-and-uinavigationcontroller/#comment-1501032470">UINavigationController和View Controller-based状态栏风格</a> &mdash;&mdash; 指定状态栏风格</p>

<p><a href="http://gracelancy.com/blog/2014/05/05/variable-argument-lists/">Variable Argument Lists</a> &mdash;&mdash; 可变参数函数的定义</p>

<p><a href="http://onevcat.com/2012/06/arc-hand-by-hand/">手把手教你ARC——iOS/Mac开发ARC入门和使用</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[爬支付宝的各种坑]]></title>
    <link href="http://limon-.github.io//blog/2015/01/07/pa-zhi-fu-bao-de-ge-chong-keng/"/>
    <updated>2015-01-07T13:57:57+08:00</updated>
    <id>http://limon-.github.io//blog/2015/01/07/pa-zhi-fu-bao-de-ge-chong-keng</id>
    <content type="html"><![CDATA[<p>爬了几天坑，在笔者崩溃之际终于集成好了，在这里分享一下经验。</p>

<p>笔者用的是<code>支付宝移动支付SDK标准版(iOS 2.1.2)</code>，申请的手机快捷支付</p>

<h2>密钥</h2>

<p>利用支付宝给的<code>openssl.exe</code>工具生成一共三种密钥，私钥、公钥，PKCS8类型的私钥</p>

<ul>
<li>公钥：放在支付宝上，去掉首尾的<code>-----BEGIN PUBLIC KEY-----``-----END PUBLIC KEY-----</code></li>
<li>PKCS8类型的私钥：如果选择在手机端签名，此私钥放在<code>NSString *privateKey = @"PKCS8类型的私钥"</code></li>
<li>私钥：此私钥带有<code>-----BEGIN RSA PRIVATE KEY-----</code> <code>-----END RSA PRIVATE KEY-----</code>，是专门给PHP用的，即在服务器端(PHP)签名，需要用到此私钥

<blockquote><p>Note：推荐服务器端签名，不过需要注意的是，PHP端用的是带<code>-----BEGIN RSA PRIVATE KEY-----</code> <code>-----END RSA PRIVATE KEY-----</code>的私钥。</p></blockquote></li>
</ul>


<h2>集成支付宝</h2>

<p>按照文档给的流程理论上想运行Demo是挺容易的，需要注意：</p>

<ul>
<li>Demo是在本地签的名，所以Demo上填写<code>NSString *privateKey = @"PKCS8类型的私钥"</code></li>
</ul>


<p>如果认为看似Demo超简单，你就错了。</p>

<h3>坑一：Undefined symbols for architecture x86_64:</h3>

<p>笔者爬过的坑，<code>ssl库</code>不支持x86_64就是64位模拟器。（若在服务器端签名不需引入ssl库）</p>

<blockquote><p>程序界公认女神@念茜给出的答案。。。</p></blockquote>

<p>也就是以下这种错误</p>

<p><img src="http://limons-gitimage.stor.sinaapp.com/alipay.png" alt="alipay error" /></p>

<p>针对这个错误，笔者尝试了各种方法，Architectures的各种设置，甚至都是一行一行对着Demo来改的，还有C++ Flage等等，最终还是不行。</p>

<p>和客服聊了一个多小时，最后客服把支付宝最老的版本和13年的版本给笔者。。。。挺好人的。。。。</p>

<h3>坑二：rsaSign()和rsaVerify()</h3>

<p>作为一个技术渣，iOS我是搞不掂了，还是搞PHP吧。。。</p>

<p>吐血的是，笔者用支付宝给的PHP版Demo，用它里面的方法<code>rsaSign()</code>签名，然后再用<code>rsaVerify()</code>验签，结果<code>rsaVerify()</code>返回的结果永远都是false，后来笔者终于准备出坑了，醒悟这个<code>rsaVerify()</code>应该不是验证这签名的。</p>

<p>后来百度了解了点皮毛：</p>

<p>RSA非对称密钥</p>

<p>① 假设A、B机器进行通信，已A机器为主；</p>

<p>② A首先需要用自己的私钥为发送请求数据签名，并将公钥一同发送给B；</p>

<p>③ B收到数据后，需要用A发送的公钥进行验证，已确保收到的数据是未经篡改的；</p>

<p>④ B验签通过后，处理逻辑，并把处理结果返回，返回数据需要用A发送的公钥进行加密（公钥加密后，只能用配对的私钥解密）；</p>

<p>⑤ A收到B返回的数据，使用私钥解密，至此，一次数据交互完成。</p>

<blockquote><p><code>rsaVerify</code>笔者猜测是验证支付宝的回调的。换句话说，签名直接就用<code>rsaSign()</code>就好了，就以下这几行代码</p></blockquote>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;?php
</span><span class='line'>include('alipay_rsa.function.php');
</span><span class='line'>
</span><span class='line'>$data = $_POST['data'];
</span><span class='line'>$sign = rsaSign($data,'../key/rsa_private_key.pem');
</span><span class='line'>
</span><span class='line'>$arr = array(
</span><span class='line'>  'sign' =&gt; $sign
</span><span class='line'>);
</span><span class='line'>
</span><span class='line'>echo json_encode($arr);
</span><span class='line'>?&gt;</span></code></pre></td></tr></table></div></figure>


<p>以为这样就爬完了？</p>

<h3>坑三：urlEncoded</h3>

<p>想着服务器直接返回<code>sign</code>直接再拼接一下就提交给支付宝，结果又掉坑里。</p>

<pre><code>NSString *signedString = json[@"sign"];
NSLog(@"signedString-----%@",signedString);

NSString *orderString = [NSString stringWithFormat:@"%@&amp;sign=\"%@\"&amp;sign_type=\"%@\"",
                             orderSpec, signedString, @"RSA"];

[[AlipaySDK defaultService] payOrder:orderString fromScheme:appScheme callback:^(NSDictionary *resultDic).....
</code></pre>

<p>又跑去和客服聊天，笔者问客服：服务器返回的<code>sign</code>应该还需要<code>urlEncoded</code>对吧，客服回我说：不用啊，服务器已经弄了啊。</p>

<pre><code>/**
* RSA签名
* @param $data 待签名数据
* @param $private_key_path 商户私钥文件路径
* return 签名结果
*/
function rsaSign($data, $private_key_path) {
    $priKey = file_get_contents($private_key_path);
    $res = openssl_pkey_get_private($priKey);
    openssl_sign($data, $sign, $res);
    openssl_free_key($res);
    //base64编码
    $sign = base64_encode($sign);
    return $sign;
}
</code></pre>

<p>客服说<code>base64_encode($sign)</code>完就可以了不需要<code>urlEncoded</code>。笔者果断还是不相信客服。</p>

<pre><code>NSString *signedString = json[@"sign"];
NSLog(@"signedString-----%@",signedString);

// 深坑啊......    
signedString = [self urlEncodedString:signedString];

NSString *orderString = [NSString stringWithFormat:@"%@&amp;sign=\"%@\"&amp;sign_type=\"%@\"",
                             orderSpec, signedString, @"RSA"];

[[AlipaySDK defaultService] payOrder:orderString fromScheme:appScheme callback:^(NSDictionary *resultDic)....
</code></pre>

<p>需要在<code>RSADataSigner.m</code>中抽离<code>-urlEncodedString</code>方法出来。。。坑啊，明明都不需要手机端签名了，当然不会去看手机端签名的具体流程啦。又没看到哪里说明服务器端返回的<code>sign</code>需要<code>urlEncoded</code>，连客服都不知道需要<code>urlEncoded</code>&hellip;..</p>

<h3>心塞，不说了&hellip;&hellip;.</h3>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ReactiveCocoa]]></title>
    <link href="http://limon-.github.io//blog/2014/12/28/reactivecocoa/"/>
    <updated>2014-12-28T17:44:25+08:00</updated>
    <id>http://limon-.github.io//blog/2014/12/28/reactivecocoa</id>
    <content type="html"><![CDATA[<h1>ReactiveCocoa</h1>

<h2>RACSignal</h2>

<h3>订阅RACSignal</h3>

<p>1.RACSignal (Subscription)
RACSignal (Subscription)类别可以看到所有的订阅事件的方法，每个方法都会将类型为(void (^)(id x))的block作为参数，当事件发生时block中的代码会执行，例如-subscribeNext:方法会传入一个block作为参数，当Signal的next事件发出后，block会接收到事件并执行。</p>

<p>2.UIKit Category
RAC为UIKit添加了很多类别来让我们可以订阅UI组件的事件，比如UITextField (RACSignalSupport)中的rac_textSignal会在文本域内容变化时发出next事件。
事件包含的内容可以是类型，只要是对象就行，如果是一些数字，布尔值等字面量，可以用@()语法装箱成NSNumber。</p>

<h3>操纵Signal</h3>

<h5>1.RACStream (Operations)</h5>

<p><code>-filter</code>:uses a block to test each value. Returns a new stream with only those values that passed.</p>

<pre><code>- (instancetype)filter:(BOOL (^)(id value))block;
    RACSequence *numbers = [@"1 2 3 4 5 6 7 8 9" componentsSeparatedByString:@"     "].rac_sequence;

// Contains: 2 4 6 8
RACSequence *filtered = [numbers filter:^ BOOL (NSString *value) {
    return (value.intValue % 2) == 0;
}];
</code></pre>

<p><code>-map</code>:Maps block across in the receiver , and transform the values. Returns a new stream with the mapped values.</p>

<pre><code>- (instancetype)map:(id (^)(id value))block;
    RACSequence *letters = [@"A B C D E F G H I" componentsSeparatedByString:@"     "].rac_sequence;

// Contains: AA BB CC DD EE FF GG HH II
RACSequence *mapped = [letters map:^(NSString *value) {
    return [value stringByAppendingString:value];
}];
</code></pre>

<p><code>-flattenMap</code>:Maps block across the values in the receiver and flattens the result. It is used to signal of signal.简单理解为：取出内部的Signal.</p>

<pre><code>[[[self.signInButton
    rac_signalForControlEvents:UIControlEventTouchUpInside]
        map:^id(id x) {
            return [self signInSignal]; // 此signal内含一个BOOL signal
    }]
    subscribeNext:^(id x) {
        NSLog(@"Sign in result: %@", x);
}];
</code></pre>

<p>打印出来的不是BOOL，<code>-subscribeNex</code>t: will execute the block whenever the signal sends a value. 但这value不包括 signal of signals：an outer signal that contains an inner signal.</p>

<pre><code>2014-01-08 21:00:25.919 RWReactivePlayground[33818:a0b] Sign in result: 
                        &lt;RACDynamicSignal: 0xa068a00&gt; name:+createSignal:
</code></pre>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>[[[self.signInButton
</span><span class='line'>   rac_signalForControlEvents:UIControlEventTouchUpInside]
</span><span class='line'>   flattenMap:^id(id x) { // subscribe to the inner signal within the outer signal’s
</span><span class='line'>     return [self signInSignal];
</span><span class='line'>   }]
</span><span class='line'>   // Output: Sign in result: 0
</span><span class='line'>   subscribeNext:^(id x) {
</span><span class='line'>     NSLog(@"Sign in result: %@", x);
</span><span class='line'>   }];</span></code></pre></td></tr></table></div></figure>


<h4>2.RACSignal (Operations)</h4>

<h2>RACObserve</h2>

<pre><code>// When self.username changes, logs the new name to the console.
//
// RACObserve(self, username) creates a new RACSignal that sends the current
// value of self.username, then the new value whenever it changes.
// -subscribeNext: will execute the block whenever the signal sends a value.
[RACObserve(self, username) subscribeNext:^(NSString *newName) {
    NSLog(@"%@", newName);
}];
</code></pre>

<h4>过滤signal</h4>

<pre><code>// Only logs names that starts with "j".
//
// -filter returns a new RACSignal that only sends a new value when its block
// returns YES.
[[RACObserve(self, username)
    filter:^(NSString *newName) {
        return [newName hasPrefix:@"j"];
    }]
    subscribeNext:^(NSString *newName) {
        NSLog(@"%@", newName);
}];
</code></pre>

<h2>Chip</h2>

<p><code>distinctUntilChanged</code>：Returns a stream of values for which -isEqual: returns NO when compared to the previous value.
用来确保signal只会发送不同的值,比较数值流中当前值和上一个值，如果不同，就返回当前值，简单理解,它将这一次的值与上一次做比较，当相同时（也包括- isEqual:）被忽略掉。</p>

<pre><code>RACSignal *validSearchSignal =
[[RACObserve(self, searchText)
  map:^id(NSString *text) {
     return @(text.length &gt; 3);
  }]
  distinctUntilChanged]; // ensure this signal only emits values when the state changes.

[validSearchSignal subscribeNext:^(id x) {
    NSLog(@"search text is valid %@", x);
}];

self.executeSearch =
[[RACCommand alloc] initWithEnabled:validSearchSignal // validSearchSignal决定button能不能点击
  signalBlock:^RACSignal *(id input) {
    return  [self executeSearchSignal];
  }];
</code></pre>

<p>例子二：比如UI上一个Label绑定了一个值，根据值更新显示的内容:</p>

<pre><code>RAC(self.label, text) = [RACObserve(self.user, username) distinctUntilChanged];
self.user.username = @"sunnyxx"; // 1st
self.user.username = @"sunnyxx"; // 2nd
self.user.username = @"sunnyxx"; // 3rd 
</code></pre>

<p>所以，对于相同值可以忽略的情况，果断加上它吧。</p>

<p><code>-takeUntilBlock</code>：对于每个next值，运行block，当block返回YES时停止取值，如：</p>

<pre><code>[[self.inputTextField.rac_textSignal takeUntilBlock:^BOOL(NSString *value) {
    return [value isEqualToString:@"stop"];
}] subscribeNext:^(NSString *value) {
    NSLog(@"current value is not `stop`: %@", value);
}];
</code></pre>

<blockquote><p>Note：停止取值的意思是，输入stop之后，无论输入什么都不会再取值，即输入stop之后，不会再有任何输出。
还有一个例子：</p></blockquote>

<pre><code>- (RACSignal*) rac_RequestStateSignal
{
    return [[RACObserve(self, state)
        takeUntilBlock:^ BOOL (NSNumber *state){
            return [state intValue] == iRequestStateComplete;
        }]
        flattenMap:^(NSNumber *state){
            if ([state intValue] == iRequestStateErrored)
            { 
                // Create a meaningful NSError here if you can.
                return [RACSignal error:nil];
            }
            else
            { 
                return [RACSignal return:state];
            }
        }];
}
</code></pre>

<p><code>-switchToLatest</code>方法用于signal-of-signals，它总是输出最新的信号的值。</p>

<pre><code>RACSubject *letters = [RACSubject subject];
RACSubject *numbers = [RACSubject subject];
RACSubject *signalOfSignals = [RACSubject subject];

RACSignal *switched = [signalOfSignals switchToLatest];

// Outputs: A B 1 D
[switched subscribeNext:^(NSString *x) {
    NSLog(@"%@", x);
}];

[signalOfSignals sendNext:letters]; // 打印letters信号内的值
[letters sendNext:@"A"];
[letters sendNext:@"B"];

[signalOfSignals sendNext:numbers]; // 打印numbers信号内的值
[letters sendNext:@"C"];
[numbers sendNext:@"1"];

[signalOfSignals sendNext:letters]; // 打印letters信号内的值
[numbers sendNext:@"2"];
[letters sendNext:@"D"];
</code></pre>

<p><code>-rac_signalForSelector:fromProtocol:</code></p>

<p>这个方法主要是把 protocal 转为一个 Signal 便于使用。值得注意的是这个函数返回的是一个 RACTuple。 这个 RACTuple 包含了 Selector 方法里面所有的参数</p>

<p><code>-rac_liftSelector:withSignalsFromArray:</code>
这个方法它的意思是当传入的 Signals 都至少sendNext过一次，接下来只要其中任意一个signal有了新的内容。就会去触发第一个 selector 参数的方法。</p>

<blockquote><p><a href="http://iiiyu.com/2014/12/26/learning-ios-notes-thirty-six/">ReactiveCocoa 用 RACSignal 替代 Delegate</a></p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CodeChip]]></title>
    <link href="http://limon-.github.io//blog/2014/12/28/codechip/"/>
    <updated>2014-12-28T00:10:03+08:00</updated>
    <id>http://limon-.github.io//blog/2014/12/28/codechip</id>
    <content type="html"><![CDATA[<h1>CodeChip</h1>

<h3>改变UITextfiedl的placeholder的颜色</h3>

<pre><code>[searchField setValue:[UIColor whiteColor] forKeyPath:@"_placeholderLabel.textColor"];
</code></pre>

<h3>统计数组中重复对象的个数</h3>

<pre><code>NSArray *array = @[@1, @2, @2, @1];
NSCountedSet *set = [[NSCountedSet alloc]initWithArray:array];

[set enumerateObjectsUsingBlock:^(id obj, BOOL *stop) {
    NSLog(@"%@ =&gt; %lu", obj, (unsigned long)[set countForObject:obj]);
}];
</code></pre>

<blockquote><p>Each distinct object inserted into an NSCountedSet object has a counter associated with it.</p></blockquote>

<p>即，NSCountedSet内的每个不同的对象都有一个与之相关的计数器。
也就是说如果遇到重复对象的加入，这个对象的计数器就会+1。所以这个类有个名叫<code>- (NSUInteger)countForObject:(id)object;</code>的方法来统计重复对象的个数。</p>

<h3>跳转到系统设置界面(只适用用iOS 8)</h3>

<pre><code>[[UIApplication sharedApplication] openURL:[NSURL URLWithString:UIApplicationOpenSettingsURLString]];
</code></pre>

<h3>跳转到APP Store（iOS 7之后）</h3>

<p>跳转到产品详情界面</p>

<pre><code>[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@"itms-apps://itunes.apple.com/app/idxxxxxx"]];
</code></pre>

<p>跳转到产品评论界面</p>

<pre><code>[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@"http://itunes.apple.com/WebObjects/MZStore.woa/wa/viewContentsUserReviews?id=xxxxxx&amp;pageNumber=0&amp;sortOrdering=2&amp;type=Purple+Software&amp;mt=8"]];
</code></pre>

<p>xxxxx是的Apple ID</p>

<h3>隐藏键盘(点击屏幕任意位置)</h3>

<p>在VC中添加</p>

<pre><code>-(void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event{
    [super touchesBegan:touches withEvent:event];
    [self.view endEditing:YES];
}   
</code></pre>

<h3>解决64位上%d和%u警告</h3>

<pre><code>#if __LP64__
#define NSI "ld"
#define NSU "lu"
#else
#define NSI "d"
#define NSU "u"
#endif 
</code></pre>

<p>使用</p>

<pre><code>NSInteger row = 2;
NSLog(@"i=%"NSI, row);
</code></pre>

<h3>判断一个view是否是另一个view的子视图</h3>

<pre><code>- (BOOL)isDescendantOfView:(UIView *)view;
</code></pre>

<h3>获取点击处的cell的indexPath</h3>

<pre><code>NSIndexPath *path = [_collectionView indexPathForItemAtPoint:[button convertPoint:CGPointZero toView:self.collectionView]];
</code></pre>

<h3>度数转换为弧度</h3>

<pre><code>#define tranformDegree(x) ((x)*(M_PI)/(180.0f))
</code></pre>

<p>弧度 = 角度* π / 180</p>

<h3>判断string是中文</h3>

<pre><code>unichar c = [searchString characterAtIndex:0];
// 汉字
if (c &gt;= 0x4E00 &amp;&amp; c &lt;= 0x9FFF){
}
</code></pre>

<h3>将数组切割成字符串</h3>

<pre><code>NSArray *array=[[NSArray alloc]initWithObjects:@"苹果",@"香蕉",@"草莓", @"菠萝", nil];
NSString *newString=[array componentsJoinedByString:@","];    
NSLog(@"%@", newString);
</code></pre>

<h3>将字符串切割成数组</h3>

<pre><code>NSString *a = [[NSString alloc] initWithString : @"冬瓜，西瓜，火龙果，大头，小狗" ];
NSArray *b = [a componentsSeparatedByString:@"，"];
</code></pre>

<h2>TableView</h2>

<h3>在包含UITableView视图中添加单击手势</h3>

<p>如果在包含UITableView视图中添加单击手势，这个单击手势会屏蔽掉UITableView的<code>didSelectRowAtIndexPath</code>
在单击点位于UITableView内的时候取消响应</p>

<pre><code>- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer{
    CGPoint point = [gestureRecognizer locationInView:self];
    if(CGRectContainsPoint(menuTableView.frame, point)){
        return NO;
    }
    return YES;
}
</code></pre>

<p>简单点的就将单击手势的cancelsTouchesInView设置为NO即可</p>

<pre><code>singleTap.cancelsTouchesInView = NO;
</code></pre>

<blockquote><p>默认为YES，若NO，Gesture Recognizers和hit-test view同时响应触摸序列</p></blockquote>

<h3>修改cell右边图标颜色</h3>

<pre><code>mytableView.tintColor = [UIColor greenColor];
</code></pre>

<h3>cell删除动画</h3>

<pre><code>//删除一个cell时，设定动画模式
[tableView deleteRowsAtIndexPaths:[NSArray arrayWithObject:indexPath] withRowAnimation:UITableViewRowAnimationFade];
</code></pre>

<h2>杂</h2>

<p>计算字符串宽度</p>

<pre><code>CGFloat priceLabelW = [priceStr sizeWithAttributes:@{NSFontAttributeName:searchResultsNameFont}].width;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[#01-字面量语法]]></title>
    <link href="http://limon-.github.io//blog/2014/12/26/number-01-zi-mian-liang-yu-fa/"/>
    <updated>2014-12-26T12:40:19+08:00</updated>
    <id>http://limon-.github.io//blog/2014/12/26/number-01-zi-mian-liang-yu-fa</id>
    <content type="html"><![CDATA[<h2>字面量数值</h2>

<p>普通创建：</p>

<pre><code>NSNumber *num = [NSNumber numberWithInt:1];
</code></pre>

<p>字面量创建</p>

<pre><code>NSNumber *nub = @1;

int a = 5;
float b = 5.32f;
NSNumber *num = @(a * b);
</code></pre>

<h2>字面量数组</h2>

<p>普通创建</p>

<pre><code>NSArray *fruits = [NSArray arrayWithObjects:@"Lemon",@"Apple",nil];
[fruits objectAtIndex:1]; // Apple
</code></pre>

<p>字面量创建</p>

<pre><code>NSArray *fruits = @[@"Lemon",@"Apple"];
fruits[1]; // Apple
</code></pre>

<p><code>fruits[1]</code>这称为取下标操作(subscripting)</p>

<h2>nil</h2>

<p>字面量创建数组，若数组元素对象中有nil，会抛出异常。因为字面量语法实际上是一种语法糖(syntactic sugar)，其效果等于是先创建了一个数组，然后把方括号内的所有对象都加到这个数组。</p>

<pre><code>NSObject *nilObject = nil;
NSArray *fruits = @[@"Lemon",nilObject,@"Apple"]; // 崩了
</code></pre>

<p>如果不用字面量创建，用<code>NSArray arrayWithObjects:</code>则不会抛出异常，只会提前结束。如下例子，遇到nil结束，fruits只有一个元素</p>

<pre><code>NSObject *nilObject = nil;
NSArray *fruits = [NSArray arrayWithObjects:@"Lemon",nilObject,@"Apple",nil];
</code></pre>

<blockquote><p>微妙的差别表明，使用字面量语法更安全。向数组插入nil通常说明程序有错，而通过异常可以更快地发现这个错误。</p></blockquote>

<h2>字面量字典</h2>

<p>值 -> 键：普通创建</p>

<pre><code>NSDictionary *personData = [NSDictionary dictionaryWithObjectsAndKeys:@"Tom",@"name",[NSNumber numberWithInt:18],@"age", nil];
[personData objectForKey:@"name"]; // Tom
</code></pre>

<p>键 -> 值：字面量语法创建</p>

<pre><code>NSDictionary *personData = @{@"name": @"Tom",@"age":@18};
personData[@"age"]; // 18
</code></pre>

<h2>可变数组和字典</h2>

<p>如果数组与字典对象是可变的(mutable)，也可以通过下标修改可变数组或字典的值</p>

<pre><code>mutableArray[1] = @"dog";
mutableDictionary[@"name"] = @"Mary";
</code></pre>

<p>普通做法：</p>

<pre><code>[mutableArray replaceObjectAtIndex:1 withObject:@"dog"];
[mutableDic setObject:@"Mary" forKey:@"name"];
</code></pre>

<h2>局限</h2>

<p>使用字面量语法创建出来的字符串、数组、字典对象都是不可变的(immutable),若想可变版本的对象，则需要赋值一份</p>

<pre><code>NSMutableDictionary *mutableDic = [@{@"name": @"Tom",@"age":@18} mutableCopy];
</code></pre>

<h2>要点</h2>

<ul>
<li>应该使用字面量语法创建字符串、数值、数组、字典。与创建此类对象的常规方法相比，更加简明扼要。</li>
<li>应该通过下标来访问数组和字典</li>
<li>用字面量语法创建数组或字典时，若值中有nil，会抛出异常。</li>
</ul>


<h2>番外</h2>

<p>JSON格式，一对 <code>{ }</code> 代表一个字典，一对<code>[]</code>代表一个数组</p>

<pre><code>{
    "result": 1,

    "school_list": [
        {
            "id": "5",
            "school_name": "清华大学"             
        },
        {
            "id": "6",
            "school_name": "北京邮电大学"
        }
    ],

    "school_near": "北京交通大学"
}
</code></pre>

<p>从JSON<strong>字典</strong>中通过键<code>school_list</code>取出数组对象</p>

<pre><code>NSArray *arr = json[@"school_list"];
NSArray *arr = [json objectForKey:@"school_list"];
</code></pre>

<p>arr数组的元素是一个个字典，遍历数组得到字典内的学校名</p>

<pre><code>for( int i=0; i&lt;arr.count; i++){
        NSString *schoolName = arr[i][@"school_name"];
        NSString *schoolName = [[arr objectAtIndex:i] objectForKey:@"school_name"];
    }
</code></pre>

<p>其实arr数组就是PHP内的二维数组，只不过在OS中，</p>

<ul>
<li>数组 - 下标为数字（PHP中的索引数组）</li>
<li>字典 - 下标为字符串（PHP中的关联数组）</li>
</ul>


<p>上面例子中二维数组arr的遍历，通过数字下标遍历二维数组中的所有元素，然后通过字符串下标取出学校名。</p>

<blockquote><p>下标也称为键</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ReactiveCocoa的三种基本的模式]]></title>
    <link href="http://limon-.github.io//blog/2014/12/26/reactivecocoa/"/>
    <updated>2014-12-26T09:35:03+08:00</updated>
    <id>http://limon-.github.io//blog/2014/12/26/reactivecocoa</id>
    <content type="html"><![CDATA[<h1>ReactiveCocoa</h1>

<hr />

<h3>三种基本的模式</h3>

<p>在ReactiveCocoa中有三种基本的模式：责任链、分割和组合模式（chaining, splitting, and combining）。</p>

<h4>一、 Chaining模式</h4>

<p>Chaining，将一个已有的signal转换为一个新的signal。常用的操作是创建一个新的signal，再对它使用filter:、map:或startWith:等方法。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>RAC(self.textField.text) = [[[RACSignal interval:1] startWith:[NSDate date]] map:^id(NSDate *value) {  
</span><span class='line'>    NSDateComponents *dateComponents = [[NSCalendar currentCalendar] components:NSMinuteCalendarUnit | NSSecondCalendarUnit fromDate:value];  
</span><span class='line'>      
</span><span class='line'>    return [NSString stringWithFormat:@"%d:%02d", dateComponents.minute, dateComponents.second];  
</span><span class='line'>}]; 
</span></code></pre></td></tr></table></div></figure>


<p>我们将textFiled的text属性绑定为三个串连的signals的结果。首先，我们创建一个间隔信号，这个信号每隔一秒钟就发送当前时间。间隔信号在没有启动的时候是不会有值的，所以我们使用startWith:启动起来。最后，使用map:将signal的NSDate值转换为一个NSString字符串，这个字符串将会被赋值到textField的text属性上。
<img src="http://teehanlax.com.s3.amazonaws.com/wordpress/wp-content/uploads/chaining.png" alt="Chaining" /></p>

<p> Chaining是最常用的操作，而且它通常不使用局部变量，而是像上面那样串连起来操作。下面的代码与上面的代码是等同的。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>RACSignal *intervalSignal = [RACSignal interval:1];  
</span><span class='line'>RACSignal *startedIntervalSignal = [intervalSignal startWith:[NSDate date]];  
</span><span class='line'>RACSignal *mappedIntervalSignal = [startedIntervalSignal map:^id(NSDate *value) {  
</span><span class='line'>    NSDateComponents *dateComponents = [[NSCalendar currentCalendar] components:NSMinuteCalendarUnit | NSSecondCalendarUnit fromDate:value];  
</span><span class='line'>      
</span><span class='line'>    return [NSString stringWithFormat:@"%d:%02d", dateComponents.minute, dateComponents.second];  
</span><span class='line'>}];  
</span><span class='line'>   
</span><span class='line'>RAC(self.textField.text) = mappedIntervalSignal;  </span></code></pre></td></tr></table></div></figure>


<h4>二、Splitting模式</h4>

<p>Splitting与chaining比较类似，也是将signal转换为其它的sginal，不同之处在于，Splitting会重复使用signal。Splitting看起来要复杂些，其实也就是一个signal使用多次。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>RACSignal *dateComponentsSignal = [[[RACSignal interval:1] startWith:[NSDate date]] map:^id(NSDate *value) {  
</span><span class='line'>    NSDateComponents *dateComponents = [[NSCalendar currentCalendar] components:NSMinuteCalendarUnit | NSSecondCalendarUnit fromDate:value];  
</span><span class='line'>    return dateComponents;  
</span><span class='line'>}];  
</span><span class='line'>   
</span><span class='line'>RAC(self.minuteTextField.text) = [dateComponentsSignal map:^id(NSDateComponents *dateComponents) {  
</span><span class='line'>    return [NSString stringWithFormat:@"%d", dateComponents.minute];  
</span><span class='line'>}];  
</span><span class='line'>   
</span><span class='line'>RAC(self.secondTextField.text) = [dateComponentsSignal map:^id(NSDateComponents *dateComponents) {  
</span><span class='line'>    return [NSString stringWithFormat:@"%d", dateComponents.second];  
</span><span class='line'>}];  </span></code></pre></td></tr></table></div></figure>


<p>在上面这个例子中，创建了一个signal，即局部变量：dateComponentsSignal。接着再用dateComponentsSignal创建两个新的signal，并将它们分别与两个textfield的text属性进行绑定。</p>

<blockquote><p>Note: 把dateComponentsSignal看作一个局部变量，就像,int a = 9; 然后多次使用a来计算。</p></blockquote>

<p><img src="http://teehanlax.com.s3.amazonaws.com/wordpress/wp-content/uploads/Splitting.png" alt="Splitting" /></p>

<h4>三、Combining模式</h4>

<p>combining就是将几个signal结合起来创建出一个新的signal。比如“登录”按钮，只有在“用户名”与“密码”输入框中的文本长度都超过6时才能被点击，否则处于不可用的状态。那么我们可以为“登录”按钮的enabled状态创建一个signal，这个signal则是由“用户名”与“密码”框它们两个自己的signal组合起来：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>RAC(self.submitButton.enabled) = [RACSignal combineLatest:@[self.usernameField.rac_textSignal, self.passwordField.rac_textSignal] reduce:^id(NSString *userName, NSString *password) {  
</span><span class='line'>    return @(userName.length &gt;= 6 && password.length &gt;= 6);  
</span><span class='line'>}]; </span></code></pre></td></tr></table></div></figure>


<p>在这里，我们将“登录”按钮的enable状态绑定到使用combineLatest:reduce:方法创建的signal上。这个方法的第二个参数是一个block，这个block的参数是combineLatest中的参数的<strong>最新值</strong>的组合。我们将两个文本框的text signal一起传到combineLatest，在reduce的block中，该block也就会接收到两个NSString的参数，这个block的工作就是将两个参数值组合起来生成一个值，然后返回。该方法的说明：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// +combineLatest:reduce: takes an array of signals, executes the block with the
</span><span class='line'>// latest value from each signal whenever any of them changes, and returns a new
</span><span class='line'>// RACSignal that sends the return value of that block as values.</span></code></pre></td></tr></table></div></figure>


<p><img src="http://teehanlax.com.s3.amazonaws.com/wordpress/wp-content/uploads/combining.png" alt="Combining" /></p>

<p>Combining常用于两种情况：</p>

<ol>
<li>需要同时满足多种条件。</li>
<li>在多个signal中进行选择。</li>
</ol>


<h2>优秀文章</h2>

<p><a href="http://www.teehanlax.com/blog/getting-started-with-reactivecocoa/">Getting Started with ReactiveCocoa</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[玩转Mantle]]></title>
    <link href="http://limon-.github.io//blog/2014/12/23/mantlede-shi-yong/"/>
    <updated>2014-12-23T10:05:15+08:00</updated>
    <id>http://limon-.github.io//blog/2014/12/23/mantlede-shi-yong</id>
    <content type="html"><![CDATA[<h2>MTLModel</h2>

<p>MTLModel provides an easy way to map NSDictionary objects to Objective-C classes and vice-versa.</p>

<p>假设返回的JSON为：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'> {
</span><span class='line'>  "uid": 1,
</span><span class='line'>  "title": "Found a bug",
</span><span class='line'>  "url": "https://api.github.com/repos/octocat/Hello-World/issues/1347",
</span><span class='line'>  "number": 1347,
</span><span class='line'>  "state": "open",
</span><span class='line'>  "user": {
</span><span class='line'>    "login": "octocat",
</span><span class='line'>    "id": 1
</span><span class='line'>  },
</span><span class='line'>  "assignee": {
</span><span class='line'>    "login": "octocat",
</span><span class='line'>    "id": 1,
</span><span class='line'>    "type": "User"
</span><span class='line'>  }
</span><span class='line'>  "created_at": "2011-04-22T13:33:48Z",
</span><span class='line'>  "awesome": true  
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>继承<code>MTLModel</code>遵守<code>&lt;MTLJSONSerializing&gt;</code>协议</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#import &lt;Mantle.h&gt;
</span><span class='line'>
</span><span class='line'>typedef enum : NSUInteger {
</span><span class='line'>    GHIssueStateOpen,
</span><span class='line'>    GHIssueStateClosed
</span><span class='line'>} GHIssueState;
</span><span class='line'>
</span><span class='line'>@interface GHIssue : MTLModel&lt;MTLJSONSerializing&gt;
</span><span class='line'>@property (nonatomic, copy, readonly) NSNumber *uid;
</span><span class='line'>@property (nonatomic, copy, readonly) NSURL *URL;
</span><span class='line'>@property (nonatomic, copy, readonly) NSNumber *number;
</span><span class='line'>@property (nonatomic, assign, readonly) GHIssueState state;
</span><span class='line'>@property (nonatomic, copy, readonly) NSString *reporterLogin;
</span><span class='line'>@property (nonatomic, copy, readonly) NSDate *updatedAt;
</span><span class='line'>@property (nonatomic, strong, readonly) GHUser *assignee;
</span><span class='line'>@property(nonatomic, getter=isAwesome) BOOL awesome;
</span><span class='line'>@property (nonatomic, copy) NSString *title;
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<p><code>&lt;MTLJSONSerializing&gt;</code>协议告诉Mantle序列化该对象如何从JSON映射到Objective-C的属性。</p>

<h3>NSValueTransformer</h3>

<p>在.m文件，实现<code>&lt;MTLJSONSerializing&gt;</code>的协议<code>@required</code>的方法<code>+ (NSDictionary *)JSONKeyPathsByPropertyKey</code>
它指明了如何把json的keypath和Model的属性对应起来</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+ (NSDictionary *)JSONKeyPathsByPropertyKey {
</span><span class='line'>  // properties defined in header  :  key in JSON Dictionary，本地字段在前，服务端字段在后
</span><span class='line'>    return @{
</span><span class='line'>        @"URL": @"url",
</span><span class='line'>        @"HTMLURL": @"html_url",
</span><span class='line'>        @"reporterLogin": @"user.login",
</span><span class='line'>        @"assignee": @"assignee",
</span><span class='line'>        @"updatedAt": @"updated_at"
</span><span class='line'>    };
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>因为如果属性名和JSON的键名一致时，可以省略不写映射，例如title</p>

<p>以上分了几种情况：
Mantle使用主要看属性property中的类型，主要分几种：</p>

<ol>
<li>NSNumber、NSString&hellip;.</li>
<li>NSArray</li>
<li>NSURL</li>
<li>NSDate</li>
<li>枚举</li>
<li>模型</li>
<li>BOOL</li>
</ol>


<p>先介绍一个方法：<code>+ (NSValueTransformer *)JSONTransformerForKey:(NSString *)key</code></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// Specifies how to convert a JSON value to the given property key. If
</span><span class='line'>// reversible, the transformer will also be used to convert the property value
</span><span class='line'>// back to JSON.
</span><span class='line'>//
</span><span class='line'>// If the receiver implements a `+&lt;key&gt;JSONTransformer` method, MTLJSONAdapter
</span><span class='line'>// will use the result of that method instead.
</span><span class='line'>//
</span><span class='line'>// Returns a value transformer, or nil if no transformation should be performed.
</span><span class='line'>+ (NSValueTransformer *)JSONTransformerForKey:(NSString *)key;
</span></code></pre></td></tr></table></div></figure>


<p>以下方法的命名都要遵从：<code>SEL selector = MTLSelectorWithKeyPattern(key, "JSONTransformer");</code></p>

<p>1、一般像tittle，<code>@"title": @"title"</code>不用写这行也自动转化。我个人认为从服务器返回的所有数据都是字符串类型。所有理论上，uid还要用<code>NSValueTransformer</code>转化，如下：</p>

<pre><code>+ (NSValueTransformer *)uidJSONTransformer{
    return [MTLValueTransformer reversibleTransformerWithForwardBlock:^id(NSString *string) {
    return @([string integerValue]);
} reverseBlock:^id(NSNumber *number) {
    return [number stringValue];
}];
</code></pre>

<p>}</p>

<p>但是，如果你的uid属性类型定义为NSNumber，还是不需用上面的方法，应该是Mantle自己处理了。</p>

<blockquote><p>如果你定义的uid类型为NSUInteger，还是需要uidJSONTransformer</p></blockquote>

<p>还有一种情况是<code>@"reporterLogin": @"user.login"</code>
   login是在JSON内层的元素，需要用下面这个方法</p>

<pre><code class="```">   + (NSValueTransformer *)reporterLoginJSONTransformer {
        return [MTLValueTransformer reversibleTransformerWithForwardBlock:^(NSArray *values) {
            return [values firstObject];
        } reverseBlock:^(NSString *str) {
            return @[str];
        }];
    }
</code></pre>

<p>2、NSArray装模型</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>  name: "Bob",
</span><span class='line'>  cars: [
</span><span class='line'>    { make: "ford", year: "1972" },
</span><span class='line'>    { make: "mazda", year: "2000" }
</span><span class='line'>  ],
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface CarModel : MTLModel
</span><span class='line'>
</span><span class='line'>@property (nonatomic, strong) NSString *make;
</span><span class='line'>@property (nonatomic, strong) NSString *year;
</span><span class='line'>
</span><span class='line'>@end
</span><span class='line'>
</span><span class='line'>@interface PersonModel : MTLModel
</span><span class='line'>
</span><span class='line'>@property (nonatomic, strong) NSString *name;
</span><span class='line'>@property (nonatomic, strong) NSArray *cars; // NSArra元素是Car模型
</span><span class='line'>
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+ (NSValueTransformer *)carsJSONTransformer {
</span><span class='line'>    return [NSValueTransformer mtl_JSONArrayTransformerWithModelClass:CarModel.class];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>3、NSURL</p>

<pre><code>+ (NSValueTransformer *)URLJSONTransformer {
    return [NSValueTransformer valueTransformerForName:MTLURLValueTransformerName];
}           
</code></pre>

<p>4、NSDate</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>+ (NSDateFormatter *)dateFormatter {
</span><span class='line'>    NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];
</span><span class='line'>    dateFormatter.locale = [[NSLocale alloc] initWithLocaleIdentifier:@"en_US_POSIX"];
</span><span class='line'>    dateFormatter.dateFormat = @"yyyy-MM-dd'T'HH:mm:ss'Z'";
</span><span class='line'>    return dateFormatter;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>+ (NSValueTransformer *)updatedAtJSONTransformer { // 把"updated_at": "2011-04-22T13:33:48Z"传给ForwardBlock
</span><span class='line'>    return [MTLValueTransformer reversibleTransformerWithForwardBlock:^(NSString *str) {
</span><span class='line'>        return [self.dateFormatter dateFromString:str]; // 把dateFormatter再传给reverseBlock
</span><span class='line'>    } reverseBlock:^(NSDate *date) {
</span><span class='line'>        return [self.dateFormatter stringFromDate:date];
</span><span class='line'>    }]
</span><span class='line'>}
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<p>如果JSON的数据格式是Unix时间戳，&#8221;date&#8221;: 1418202490,</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+ (NSValueTransformer *)dateJSONTransformer {
</span><span class='line'>    return [MTLValueTransformer reversibleTransformerWithForwardBlock:^(NSString *str) {
</span><span class='line'>        return [NSDate dateWithTimeIntervalSince1970:str.floatValue];
</span><span class='line'>    } reverseBlock:^(NSDate *date) {
</span><span class='line'>        return [NSString stringWithFormat:@"%f",[date timeIntervalSince1970]];
</span><span class='line'>    }];
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<p>5、枚举</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+ (NSValueTransformer *)stateJSONTransformer {
</span><span class='line'>    return [NSValueTransformer mtl_valueMappingTransformerWithDictionary:@{
</span><span class='line'>        @"open": @(GHIssueStateOpen),
</span><span class='line'>        @"closed": @(GHIssueStateClosed)
</span><span class='line'>    }];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>6、模型</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+ (NSValueTransformer *)assigneeJSONTransformer {
</span><span class='line'>    return [NSValueTransformer mtl_JSONDictionaryTransformerWithModelClass:GHUser.class];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>7、 BOOL</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+ (NSValueTransformer *)awesomeJSONTransformer {
</span><span class='line'>    return [NSValueTransformer valueTransformerForName:MTLBooleanValueTransformerName];
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<h2>空对象处理</h2>

<p>在模型.m文件添加<code>-setNilValueForKey</code>，Mantle是基于KVC给property赋值的，KVC提供了<code>-setNilValueForKey</code>方法，让我们为nil指定一个合理的替代值</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>@interface MTLModel (KTVNullableScalar)
</span><span class='line'>@end
</span><span class='line'>@implementation MTLModel (KTVNullableScalar)
</span><span class='line'>- (void)setNilValueForKey:(NSString *)key {
</span><span class='line'>    [self setValue:@0 forKey:key];  // For NSInteger/CGFloat/BOOL
</span><span class='line'>}
</span><span class='line'>@end</span></code></pre></td></tr></table></div></figure>


<h2>Create model objects from JSON</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// create NSDictionary from JSON data
</span><span class='line'>NSData JSONData = ... // the JSON response from the API
</span><span class='line'>NSError *error = nil;
</span><span class='line'>NSDictionary *JSONDict = [NSJSONSerialization JSONObjectWithData:JSONData options:0 error:&error];
</span><span class='line'>
</span><span class='line'>// create model object from NSDictionary using MTLJSONSerialisation
</span><span class='line'>CATProfile *profile = [MTLJSONAdapter modelOfClass:CATProfile.class fromJSONDictionary:JSONDict error:NULL];</span></code></pre></td></tr></table></div></figure>


<h2>Create JSON from model objects</h2>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>// create NSDictionary from model class using MTLJSONSerialisation
</span><span class='line'>CATProfile *profile = ...
</span><span class='line'>NSDictionary *profileDict = [MTLJSONAdapter JSONDictionaryFromModel:profile];
</span><span class='line'>NSError *error = nil;
</span><span class='line'>// convert NSDictionary to JSON data
</span><span class='line'>NSData *JSONData = [NSJSONSerialization dataWithJSONObject:profileDict options:0 error:&error];</span></code></pre></td></tr></table></div></figure>


<blockquote><p>Note：如果不想JSONData含有模型的某个属性，可以在模型JSONKeyPathsByPropertyKey方法中
    return @{ @&ldquo;Name&rdquo;: NSNull.null };</p></blockquote>

<h2>Serialize 序列化</h2>

<p>待续&hellip;</p>

<h2>优秀文章</h2>

<p><a href="http://spin.atomicobject.com/2014/06/23/ios-models-mantle/">Simplify iOS Models With Mantle – An Intro</a></p>

<p><a href="http://www.objc.at/mantle">mantle</a></p>

<p><a href="http://www.cnblogs.com/ipinka/p/4041835.html">iOS的Mantle实战</a></p>

<p><a href="http://ke.gitcafe.io/2014/10/13/Why-Changba-iOS-choose-Mantle/">为什么唱吧iOS 6.0选择了Mantle</a></p>
]]></content>
  </entry>
  
</feed>
